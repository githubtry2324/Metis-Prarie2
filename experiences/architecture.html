<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Li Bâtimân - Métis Architecture</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #2d1810 0%, #4a3020 50%, #1a0f08 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: #e8d5c4;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(139, 90, 43, 0.8);
            color: #e8d5c4;
            border: 2px solid #d4a574;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .back-button:hover {
            background: rgba(212, 165, 116, 0.9);
            color: #2d1810;
            transform: scale(1.05);
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .title-section {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
        }

        .title-section h1 {
            font-size: 2.5rem;
            color: #d4a574;
            text-shadow: 0 0 20px rgba(212, 165, 116, 0.5);
            margin-bottom: 5px;
            letter-spacing: 3px;
        }

        .title-section .subtitle {
            font-size: 1.2rem;
            color: #c9b896;
            font-style: italic;
            opacity: 0.9;
        }

        .building-selector {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
        }

        .building-btn {
            background: rgba(45, 24, 16, 0.85);
            border: 2px solid #8b5a2b;
            color: #d4a574;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            min-width: 140px;
        }

        .building-btn:hover {
            background: rgba(139, 90, 43, 0.9);
            border-color: #d4a574;
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(212, 165, 116, 0.3);
        }

        .building-btn.active {
            background: rgba(212, 165, 116, 0.9);
            color: #2d1810;
            border-color: #e8d5c4;
        }

        .info-panel {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 320px;
            background: rgba(45, 24, 16, 0.92);
            border: 2px solid #8b5a2b;
            border-radius: 15px;
            padding: 25px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            max-height: 70vh;
            overflow-y: auto;
        }

        .info-panel h2 {
            color: #d4a574;
            font-size: 1.5rem;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(212, 165, 116, 0.3);
            padding-bottom: 10px;
        }

        .info-panel .michif-name {
            color: #c9b896;
            font-style: italic;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }

        .info-panel p {
            line-height: 1.7;
            margin-bottom: 15px;
            font-size: 0.95rem;
        }

        .feature-list {
            list-style: none;
            margin-top: 15px;
        }

        .feature-list li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
            border-bottom: 1px solid rgba(139, 90, 43, 0.3);
        }

        .feature-list li::before {
            content: '▸';
            position: absolute;
            left: 5px;
            color: #d4a574;
        }

        .construction-demo {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            background: rgba(45, 24, 16, 0.92);
            border: 2px solid #8b5a2b;
            border-radius: 15px;
            padding: 20px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .construction-demo h3 {
            color: #d4a574;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .build-progress {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .build-step {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(139, 90, 43, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .build-step:hover {
            background: rgba(139, 90, 43, 0.4);
            border-color: #8b5a2b;
        }

        .build-step.active {
            background: rgba(212, 165, 116, 0.3);
            border-color: #d4a574;
        }

        .build-step.completed {
            opacity: 0.6;
        }

        .step-number {
            width: 28px;
            height: 28px;
            background: #8b5a2b;
            color: #e8d5c4;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .build-step.completed .step-number {
            background: #5a8b2b;
        }

        .step-label {
            flex: 1;
            font-size: 0.9rem;
        }

        .auto-build-btn {
            margin-top: 15px;
            width: 100%;
            background: linear-gradient(135deg, #8b5a2b, #d4a574);
            border: none;
            color: #2d1810;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .auto-build-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(212, 165, 116, 0.4);
        }

        .reset-btn {
            margin-top: 8px;
            width: 100%;
            background: transparent;
            border: 1px solid #8b5a2b;
            color: #d4a574;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            background: rgba(139, 90, 43, 0.3);
        }

        .hint-text {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #c9b896;
            font-size: 0.9rem;
            opacity: 0.7;
            text-align: center;
        }

        @media (max-width: 1200px) {
            .info-panel {
                width: 280px;
                right: 20px;
                padding: 20px;
            }
            .construction-demo {
                width: 240px;
                left: 20px;
            }
        }

        @media (max-width: 900px) {
            .info-panel, .construction-demo {
                position: relative;
                transform: none;
                top: auto;
                right: auto;
                left: auto;
                width: 90%;
                margin: 20px auto;
                max-height: none;
            }
            #ui-overlay {
                position: relative;
                height: auto;
                padding-top: 60vh;
            }
            .title-section {
                position: relative;
                top: 20px;
                transform: translateX(-50%);
            }
        }

        /* Credit footer */
        .experience-credit {
            position: fixed;
            bottom: 15px;
            right: 20px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            text-align: right;
            pointer-events: none;
            z-index: 100;
        }
        .experience-credit .designer {
            color: rgba(255, 215, 0, 0.6);
        }
    </style>
</head>
<body>
    <button class="back-button" onclick="window.history.back()">← Back to Prairie</button>

    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div class="title-section">
            <h1>Li Bâtimân</h1>
            <div class="subtitle">The Buildings of the Métis</div>
        </div>

        <div class="construction-demo">
            <h3>Build Step by Step</h3>
            <div class="build-progress">
                <div class="build-step" data-step="1">
                    <span class="step-number">1</span>
                    <span class="step-label">Foundation Logs</span>
                </div>
                <div class="build-step" data-step="2">
                    <span class="step-number">2</span>
                    <span class="step-label">Corner Posts (Poteaux)</span>
                </div>
                <div class="build-step" data-step="3">
                    <span class="step-number">3</span>
                    <span class="step-label">Wall Frame</span>
                </div>
                <div class="build-step" data-step="4">
                    <span class="step-number">4</span>
                    <span class="step-label">Horizontal Logs</span>
                </div>
                <div class="build-step" data-step="5">
                    <span class="step-number">5</span>
                    <span class="step-label">Roof Structure</span>
                </div>
                <div class="build-step" data-step="6">
                    <span class="step-number">6</span>
                    <span class="step-label">Thatching & Details</span>
                </div>
            </div>
            <button class="auto-build-btn" id="auto-build">▶ Watch It Build</button>
            <button class="reset-btn" id="reset-build">Reset</button>
        </div>

        <div class="info-panel">
            <h2 id="building-title">Red River Frame</h2>
            <div class="michif-name" id="building-michif">Maison en Poteaux</div>
            <p id="building-description">
                The Red River Frame style was perfected by the Métis, blending French-Canadian
                building techniques with the practical needs of prairie life. Vertical posts
                were set into the ground, with horizontal logs fitted between them using the
                "pièce-sur-pièce" method.
            </p>
            <ul class="feature-list" id="feature-list">
                <li>Vertical posts (poteaux) anchored in ground</li>
                <li>Horizontal logs between posts</li>
                <li>Whitewashed exterior for weather protection</li>
                <li>Steep roof for snow shedding</li>
                <li>Central fireplace for heating</li>
            </ul>
        </div>

        <div class="building-selector">
            <button class="building-btn active" data-building="redriver">Red River Frame</button>
            <button class="building-btn" data-building="logcabin">Log Cabin</button>
            <button class="building-btn" data-building="hivernant">Hivernant Lodge</button>
            <button class="building-btn" data-building="storehouse">Cache / Storehouse</button>
        </div>

        <div class="hint-text">Click and drag to rotate • Scroll to zoom</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Building data
        const buildings = {
            redriver: {
                title: "Red River Frame",
                michif: "Maison en Poteaux",
                description: "The Red River Frame style was perfected by the Métis, blending French-Canadian building techniques with the practical needs of prairie life. Vertical posts were set into the ground, with horizontal logs fitted between them using the 'pièce-sur-pièce' method.",
                features: [
                    "Vertical posts (poteaux) anchored in ground",
                    "Horizontal logs fitted between posts",
                    "Whitewashed exterior for weather protection",
                    "Steep roof for snow shedding",
                    "Central fireplace for heating"
                ]
            },
            logcabin: {
                title: "Log Cabin",
                michif: "Cabane en Bois Rond",
                description: "Simple but sturdy log cabins were built by Métis families for temporary camps and permanent homesteads. Notched corners locked the logs together without nails, and gaps were filled with moss, mud, or buffalo hair mixed with clay.",
                features: [
                    "Notched corner joints (no nails needed)",
                    "Chinked gaps with mud and moss",
                    "Small windows to retain heat",
                    "Sod or bark roof covering",
                    "Earthen floor, sometimes planked"
                ]
            },
            hivernant: {
                title: "Hivernant Lodge",
                michif: "Lôzh d'Hivernement",
                description: "Winter camps required quick, warm shelters. The Métis hivernant (winterer) lodge combined elements of Indigenous tipis with European cabin construction. A wooden frame was covered with buffalo hides or canvas, banked with snow for insulation.",
                features: [
                    "Portable wooden frame structure",
                    "Buffalo hide or canvas covering",
                    "Central fire pit with smoke hole",
                    "Snow-banked walls for insulation",
                    "Quick assembly for hunting camps"
                ]
            },
            storehouse: {
                title: "Cache / Storehouse",
                michif: "La Cache",
                description: "Essential for storing pemmican, dried meat, and furs, the cache was built on stilts to keep contents safe from animals and moisture. Some were partially buried for temperature control, protecting food through harsh winters.",
                features: [
                    "Raised on posts away from ground",
                    "Small, secure door",
                    "Ventilation gaps for air flow",
                    "Sometimes partially buried",
                    "Holds pemmican, furs, and tools"
                ]
            }
        };

        // Scene setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1510);
        scene.fog = new THREE.Fog(0x1a1510, 15, 50);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(8, 6, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.minDistance = 5;
        controls.maxDistance = 25;
        controls.target.set(0, 2, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        sunLight.position.set(10, 15, 8);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 50;
        sunLight.shadow.camera.left = -15;
        sunLight.shadow.camera.right = 15;
        sunLight.shadow.camera.top = 15;
        sunLight.shadow.camera.bottom = -15;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0xaaccff, 0.3);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        // Ground
        const groundGeo = new THREE.CircleGeometry(20, 64);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x3d5c3a,
            roughness: 0.9
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Materials
        const logMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6914,
            roughness: 0.85
        });

        const darkLogMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.9
        });

        const roofMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a4030,
            roughness: 0.95
        });

        const whitewashMaterial = new THREE.MeshStandardMaterial({
            color: 0xe8dcc8,
            roughness: 0.7
        });

        // Building parts group
        let buildingGroup = new THREE.Group();
        scene.add(buildingGroup);

        // Build steps storage
        let buildSteps = [];
        let currentStep = 0;
        let currentBuilding = 'redriver';

        // Create log geometry helper
        function createLog(length, radius = 0.12) {
            const geo = new THREE.CylinderGeometry(radius, radius * 0.95, length, 8);
            geo.rotateZ(Math.PI / 2);
            return geo;
        }

        // Build Red River Frame house
        function buildRedRiverFrame() {
            buildSteps = [];
            const step1 = new THREE.Group(); // Foundation
            const step2 = new THREE.Group(); // Corner posts
            const step3 = new THREE.Group(); // Wall frame
            const step4 = new THREE.Group(); // Horizontal logs
            const step5 = new THREE.Group(); // Roof
            const step6 = new THREE.Group(); // Details

            // Step 1: Foundation logs
            const foundationPositions = [
                { x: 0, z: -2 }, { x: 0, z: 2 }
            ];
            foundationPositions.forEach(pos => {
                const log = new THREE.Mesh(createLog(5, 0.18), darkLogMaterial);
                log.position.set(pos.x, 0.15, pos.z);
                log.castShadow = true;
                step1.add(log);
            });
            [-2, 2].forEach(x => {
                const log = new THREE.Mesh(createLog(4, 0.18), darkLogMaterial);
                log.position.set(x, 0.15, 0);
                log.rotation.y = Math.PI / 2;
                log.castShadow = true;
                step1.add(log);
            });

            // Step 2: Corner posts (poteaux)
            const postPositions = [
                { x: -2.2, z: -1.8 }, { x: 2.2, z: -1.8 },
                { x: -2.2, z: 1.8 }, { x: 2.2, z: 1.8 }
            ];
            postPositions.forEach(pos => {
                const postGeo = new THREE.CylinderGeometry(0.15, 0.18, 3.5, 8);
                const post = new THREE.Mesh(postGeo, logMaterial);
                post.position.set(pos.x, 1.75, pos.z);
                post.castShadow = true;
                step2.add(post);
            });

            // Step 3: Wall frame (top beams)
            const topBeams = [
                { x: 0, z: -1.8, rotY: 0, len: 4.8 },
                { x: 0, z: 1.8, rotY: 0, len: 4.8 },
                { x: -2.2, z: 0, rotY: Math.PI/2, len: 3.8 },
                { x: 2.2, z: 0, rotY: Math.PI/2, len: 3.8 }
            ];
            topBeams.forEach(beam => {
                const log = new THREE.Mesh(createLog(beam.len, 0.12), logMaterial);
                log.position.set(beam.x, 3.5, beam.z);
                log.rotation.y = beam.rotY;
                log.castShadow = true;
                step3.add(log);
            });

            // Step 4: Horizontal wall logs
            for (let y = 0.6; y < 3.3; y += 0.35) {
                // Front and back walls
                [-1.8, 1.8].forEach(z => {
                    const log = new THREE.Mesh(createLog(4.2, 0.1), whitewashMaterial);
                    log.position.set(0, y, z);
                    log.castShadow = true;
                    step4.add(log);
                });
                // Side walls
                [-2.2, 2.2].forEach(x => {
                    const log = new THREE.Mesh(createLog(3.4, 0.1), whitewashMaterial);
                    log.position.set(x, y, 0);
                    log.rotation.y = Math.PI / 2;
                    log.castShadow = true;
                    step4.add(log);
                });
            }

            // Step 5: Roof structure
            const roofGroup = new THREE.Group();
            // Ridge beam
            const ridge = new THREE.Mesh(createLog(5.5, 0.15), logMaterial);
            ridge.position.set(0, 5.5, 0);
            roofGroup.add(ridge);
            // Rafters
            for (let x = -2; x <= 2; x += 1) {
                [-1, 1].forEach(side => {
                    const rafterGeo = new THREE.CylinderGeometry(0.08, 0.08, 3, 6);
                    rafterGeo.rotateZ(Math.PI / 2);
                    const rafter = new THREE.Mesh(rafterGeo, logMaterial);
                    rafter.position.set(x, 4.5, side * 1.2);
                    rafter.rotation.x = side * 0.7;
                    rafter.castShadow = true;
                    roofGroup.add(rafter);
                });
            }
            step5.add(roofGroup);

            // Step 6: Roof covering and details
            const roofShape = new THREE.Shape();
            roofShape.moveTo(-2.8, 0);
            roofShape.lineTo(0, 2.2);
            roofShape.lineTo(2.8, 0);
            roofShape.lineTo(-2.8, 0);
            const roofExtrudeSettings = { depth: 5.5, bevelEnabled: false };
            const roofCoverGeo = new THREE.ExtrudeGeometry(roofShape, roofExtrudeSettings);
            roofCoverGeo.rotateX(Math.PI / 2);
            roofCoverGeo.translate(0, 3.5, 2.75);
            const roofCover = new THREE.Mesh(roofCoverGeo, roofMaterial);
            roofCover.castShadow = true;
            step6.add(roofCover);

            // Door
            const doorGeo = new THREE.BoxGeometry(0.8, 1.8, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 1.2, 1.85);
            step6.add(door);

            // Window
            const windowGeo = new THREE.BoxGeometry(0.6, 0.5, 0.1);
            const windowMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.6 });
            const window1 = new THREE.Mesh(windowGeo, windowMat);
            window1.position.set(-1.2, 2, 1.85);
            step6.add(window1);

            buildSteps = [step1, step2, step3, step4, step5, step6];
            buildSteps.forEach(step => {
                step.visible = false;
                buildingGroup.add(step);
            });
        }

        // Build Log Cabin
        function buildLogCabin() {
            buildSteps = [];
            const step1 = new THREE.Group(); // Foundation
            const step2 = new THREE.Group(); // Corner notches
            const step3 = new THREE.Group(); // Lower walls
            const step4 = new THREE.Group(); // Upper walls
            const step5 = new THREE.Group(); // Roof frame
            const step6 = new THREE.Group(); // Roof and details

            // Step 1: Foundation logs
            for (let i = 0; i < 2; i++) {
                const log = new THREE.Mesh(createLog(4.5, 0.2), darkLogMaterial);
                log.position.set(0, 0.2, -1.5 + i * 3);
                log.castShadow = true;
                step1.add(log);
            }

            // Step 2: First layer with notches
            const firstLayer = [
                { x: 0, z: -1.8, rotY: 0 },
                { x: 0, z: 1.8, rotY: 0 },
                { x: -1.8, z: 0, rotY: Math.PI/2 },
                { x: 1.8, z: 0, rotY: Math.PI/2 }
            ];
            firstLayer.forEach(pos => {
                const log = new THREE.Mesh(createLog(4.2, 0.18), logMaterial);
                log.position.set(pos.x, 0.5, pos.z);
                log.rotation.y = pos.rotY;
                log.castShadow = true;
                step2.add(log);
            });

            // Step 3 & 4: Stacked log walls
            for (let layer = 1; layer <= 8; layer++) {
                const y = 0.5 + layer * 0.35;
                const stepGroup = layer <= 4 ? step3 : step4;

                // Alternating pattern
                if (layer % 2 === 1) {
                    [-1.8, 1.8].forEach(z => {
                        const log = new THREE.Mesh(createLog(4.2, 0.16), logMaterial);
                        log.position.set(0, y, z);
                        log.castShadow = true;
                        stepGroup.add(log);
                    });
                } else {
                    [-1.8, 1.8].forEach(x => {
                        const log = new THREE.Mesh(createLog(4.2, 0.16), logMaterial);
                        log.position.set(x, y, 0);
                        log.rotation.y = Math.PI / 2;
                        log.castShadow = true;
                        stepGroup.add(log);
                    });
                }
            }

            // Step 5: Roof frame
            const ridgePole = new THREE.Mesh(createLog(5, 0.12), logMaterial);
            ridgePole.position.set(0, 5, 0);
            step5.add(ridgePole);

            for (let x = -1.5; x <= 1.5; x += 1.5) {
                const rafter1 = new THREE.Mesh(createLog(2.8, 0.08), logMaterial);
                rafter1.position.set(x, 4.2, -1);
                rafter1.rotation.set(0.8, 0, 0);
                step5.add(rafter1);

                const rafter2 = new THREE.Mesh(createLog(2.8, 0.08), logMaterial);
                rafter2.position.set(x, 4.2, 1);
                rafter2.rotation.set(-0.8, 0, 0);
                step5.add(rafter2);
            }

            // Step 6: Roof covering
            const roofGeo = new THREE.BoxGeometry(5, 0.15, 3);
            const roof1 = new THREE.Mesh(roofGeo, roofMaterial);
            roof1.position.set(0, 4.3, -1.3);
            roof1.rotation.x = 0.6;
            roof1.castShadow = true;
            step6.add(roof1);

            const roof2 = new THREE.Mesh(roofGeo, roofMaterial);
            roof2.position.set(0, 4.3, 1.3);
            roof2.rotation.x = -0.6;
            roof2.castShadow = true;
            step6.add(roof2);

            // Door
            const doorGeo = new THREE.BoxGeometry(0.7, 1.5, 0.15);
            const door = new THREE.Mesh(doorGeo, darkLogMaterial);
            door.position.set(0, 1.3, 1.88);
            step6.add(door);

            buildSteps = [step1, step2, step3, step4, step5, step6];
            buildSteps.forEach(step => {
                step.visible = false;
                buildingGroup.add(step);
            });
        }

        // Build Hivernant Lodge
        function buildHivernantLodge() {
            buildSteps = [];
            const step1 = new THREE.Group(); // Base frame
            const step2 = new THREE.Group(); // Corner poles
            const step3 = new THREE.Group(); // Cross beams
            const step4 = new THREE.Group(); // Frame poles
            const step5 = new THREE.Group(); // Hide covering frame
            const step6 = new THREE.Group(); // Covering and details

            // Step 1: Base circle
            const baseRadius = 2.5;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const log = new THREE.Mesh(createLog(2, 0.1), darkLogMaterial);
                log.position.set(Math.cos(angle) * baseRadius, 0.1, Math.sin(angle) * baseRadius);
                log.rotation.y = angle + Math.PI / 2;
                step1.add(log);
            }

            // Step 2: Main poles
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const poleGeo = new THREE.CylinderGeometry(0.08, 0.1, 4.5, 6);
                const pole = new THREE.Mesh(poleGeo, logMaterial);
                pole.position.set(
                    Math.cos(angle) * baseRadius * 0.9,
                    2.2,
                    Math.sin(angle) * baseRadius * 0.9
                );
                pole.rotation.z = 0.25;
                pole.rotation.y = -angle;
                pole.castShadow = true;
                step2.add(pole);
            }

            // Step 3: Cross beams
            const crossBeam1 = new THREE.Mesh(createLog(4, 0.08), logMaterial);
            crossBeam1.position.set(0, 3.5, 0);
            step3.add(crossBeam1);

            const crossBeam2 = new THREE.Mesh(createLog(4, 0.08), logMaterial);
            crossBeam2.position.set(0, 3.5, 0);
            crossBeam2.rotation.y = Math.PI / 2;
            step3.add(crossBeam2);

            // Step 4: Additional frame poles
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.PI / 8;
                const poleGeo = new THREE.CylinderGeometry(0.05, 0.06, 3.5, 6);
                const pole = new THREE.Mesh(poleGeo, logMaterial);
                pole.position.set(
                    Math.cos(angle) * baseRadius * 0.85,
                    1.8,
                    Math.sin(angle) * baseRadius * 0.85
                );
                pole.rotation.z = 0.3;
                pole.rotation.y = -angle;
                step4.add(pole);
            }

            // Step 5: Frame for covering
            const frameRing = new THREE.Mesh(
                new THREE.TorusGeometry(2, 0.06, 6, 16),
                logMaterial
            );
            frameRing.position.set(0, 2.5, 0);
            frameRing.rotation.x = Math.PI / 2;
            step5.add(frameRing);

            // Step 6: Hide covering (cone shape)
            const coneGeo = new THREE.ConeGeometry(2.8, 3.8, 16, 1, true);
            const hideMat = new THREE.MeshStandardMaterial({
                color: 0xb8a080,
                roughness: 0.95,
                side: THREE.DoubleSide
            });
            const covering = new THREE.Mesh(coneGeo, hideMat);
            covering.position.set(0, 2.2, 0);
            covering.castShadow = true;
            step6.add(covering);

            // Smoke hole opening indicator
            const smokeHole = new THREE.Mesh(
                new THREE.RingGeometry(0.3, 0.5, 16),
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            smokeHole.position.set(0, 4.1, 0);
            smokeHole.rotation.x = -Math.PI / 2;
            step6.add(smokeHole);

            // Door flap
            const flapGeo = new THREE.PlaneGeometry(0.8, 1.5);
            const flap = new THREE.Mesh(flapGeo, hideMat);
            flap.position.set(0, 1, 2.6);
            step6.add(flap);

            buildSteps = [step1, step2, step3, step4, step5, step6];
            buildSteps.forEach(step => {
                step.visible = false;
                buildingGroup.add(step);
            });
        }

        // Build Cache/Storehouse
        function buildStorehouse() {
            buildSteps = [];
            const step1 = new THREE.Group(); // Support posts
            const step2 = new THREE.Group(); // Platform
            const step3 = new THREE.Group(); // Wall frame
            const step4 = new THREE.Group(); // Walls
            const step5 = new THREE.Group(); // Roof frame
            const step6 = new THREE.Group(); // Roof and door

            // Step 1: Four support posts
            const postPositions = [
                { x: -1, z: -0.8 }, { x: 1, z: -0.8 },
                { x: -1, z: 0.8 }, { x: 1, z: 0.8 }
            ];
            postPositions.forEach(pos => {
                const postGeo = new THREE.CylinderGeometry(0.15, 0.18, 2.5, 8);
                const post = new THREE.Mesh(postGeo, logMaterial);
                post.position.set(pos.x, 1.25, pos.z);
                post.castShadow = true;
                step1.add(post);
            });

            // Step 2: Platform
            const platformLogs = [];
            for (let z = -0.6; z <= 0.6; z += 0.4) {
                const log = new THREE.Mesh(createLog(2.4, 0.12), logMaterial);
                log.position.set(0, 2.5, z);
                log.castShadow = true;
                step2.add(log);
            }
            // Cross supports
            [-0.8, 0.8].forEach(z => {
                const support = new THREE.Mesh(createLog(2.2, 0.1), darkLogMaterial);
                support.position.set(0, 2.35, z);
                support.rotation.y = Math.PI / 2;
                step2.add(support);
            });

            // Step 3: Corner frame
            postPositions.forEach(pos => {
                const framePost = new THREE.CylinderGeometry(0.08, 0.08, 1.8, 6);
                const post = new THREE.Mesh(framePost, logMaterial);
                post.position.set(pos.x, 3.5, pos.z);
                post.castShadow = true;
                step3.add(post);
            });

            // Step 4: Walls
            for (let y = 2.7; y < 4.3; y += 0.25) {
                [-0.8, 0.8].forEach(z => {
                    const log = new THREE.Mesh(createLog(2.2, 0.08), logMaterial);
                    log.position.set(0, y, z);
                    step4.add(log);
                });
                if (y < 4.0) {
                    [-1, 1].forEach(x => {
                        const log = new THREE.Mesh(createLog(1.4, 0.08), logMaterial);
                        log.position.set(x, y, 0);
                        log.rotation.y = Math.PI / 2;
                        step4.add(log);
                    });
                }
            }

            // Step 5: Roof frame
            const ridgePole = new THREE.Mesh(createLog(3, 0.1), logMaterial);
            ridgePole.position.set(0, 5.2, 0);
            step5.add(ridgePole);

            [-0.8, 0, 0.8].forEach(x => {
                const rafter1 = new THREE.Mesh(createLog(1.5, 0.06), logMaterial);
                rafter1.position.set(x, 4.7, -0.5);
                rafter1.rotation.set(0.6, 0, 0);
                step5.add(rafter1);

                const rafter2 = new THREE.Mesh(createLog(1.5, 0.06), logMaterial);
                rafter2.position.set(x, 4.7, 0.5);
                rafter2.rotation.set(-0.6, 0, 0);
                step5.add(rafter2);
            });

            // Step 6: Roof covering
            const roofGeo = new THREE.BoxGeometry(2.8, 0.1, 1.5);
            const roof1 = new THREE.Mesh(roofGeo, roofMaterial);
            roof1.position.set(0, 4.75, -0.6);
            roof1.rotation.x = 0.5;
            roof1.castShadow = true;
            step6.add(roof1);

            const roof2 = new THREE.Mesh(roofGeo, roofMaterial);
            roof2.position.set(0, 4.75, 0.6);
            roof2.rotation.x = -0.5;
            roof2.castShadow = true;
            step6.add(roof2);

            // Small door
            const doorGeo = new THREE.BoxGeometry(0.5, 0.7, 0.08);
            const door = new THREE.Mesh(doorGeo, darkLogMaterial);
            door.position.set(0, 3.2, 0.85);
            step6.add(door);

            buildSteps = [step1, step2, step3, step4, step5, step6];
            buildSteps.forEach(step => {
                step.visible = false;
                buildingGroup.add(step);
            });
        }

        // Initialize with Red River Frame
        function initBuilding(type) {
            // Clear previous
            while(buildingGroup.children.length > 0) {
                buildingGroup.remove(buildingGroup.children[0]);
            }
            currentStep = 0;

            switch(type) {
                case 'logcabin':
                    buildLogCabin();
                    break;
                case 'hivernant':
                    buildHivernantLodge();
                    break;
                case 'storehouse':
                    buildStorehouse();
                    break;
                default:
                    buildRedRiverFrame();
            }

            updateStepUI();
        }

        // Update step UI
        function updateStepUI() {
            const stepEls = document.querySelectorAll('.build-step');
            stepEls.forEach((el, index) => {
                el.classList.remove('active', 'completed');
                if (index < currentStep) {
                    el.classList.add('completed');
                } else if (index === currentStep) {
                    el.classList.add('active');
                }
            });
        }

        // Show step
        function showStep(stepIndex) {
            if (stepIndex < 0 || stepIndex >= buildSteps.length) return;

            currentStep = stepIndex;
            buildSteps.forEach((step, i) => {
                step.visible = i <= stepIndex;
            });
            updateStepUI();
        }

        // Auto build animation
        let isBuilding = false;
        function autoBuild() {
            if (isBuilding) return;
            isBuilding = true;

            // Reset first
            buildSteps.forEach(step => step.visible = false);
            currentStep = -1;

            let step = 0;
            const buildInterval = setInterval(() => {
                if (step < buildSteps.length) {
                    showStep(step);
                    step++;
                } else {
                    clearInterval(buildInterval);
                    isBuilding = false;
                }
            }, 800);
        }

        // Reset build
        function resetBuild() {
            buildSteps.forEach(step => step.visible = false);
            currentStep = 0;
            updateStepUI();
        }

        // Update info panel
        function updateInfoPanel(type) {
            const data = buildings[type];
            document.getElementById('building-title').textContent = data.title;
            document.getElementById('building-michif').textContent = data.michif;
            document.getElementById('building-description').textContent = data.description;

            const featureList = document.getElementById('feature-list');
            featureList.innerHTML = data.features.map(f => `<li>${f}</li>`).join('');
        }

        // Event listeners
        document.querySelectorAll('.building-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.building-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const buildingType = btn.getAttribute('data-building');
                currentBuilding = buildingType;
                initBuilding(buildingType);
                updateInfoPanel(buildingType);
            });
        });

        document.querySelectorAll('.build-step').forEach(stepEl => {
            stepEl.addEventListener('click', () => {
                const stepNum = parseInt(stepEl.getAttribute('data-step')) - 1;
                showStep(stepNum);
            });
        });

        document.getElementById('auto-build').addEventListener('click', autoBuild);
        document.getElementById('reset-build').addEventListener('click', resetBuild);

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        initBuilding('redriver');
        updateInfoPanel('redriver');
        animate();
    </script>

    <div class="experience-credit">
        Designed by <span class="designer">Amarah Ishaque</span><br>
        EDU596 Métis Foundational Knowledge
    </div>
</body>
</html>
