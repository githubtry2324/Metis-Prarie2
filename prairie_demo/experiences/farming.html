<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Li Loo di Rivyair - The River Lot (Daylight)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Manrope:wght@300;500;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky Blue Fallback */
            font-family: 'Manrope', sans-serif;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            border: 2px solid #00BFFF;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-family: 'Manrope', sans-serif;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .back-button:hover {
            background: rgba(0, 191, 255, 0.9);
            color: white;
            transform: scale(1.05);
        }

        /* Airy, Bright Vignette */
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(255,255,255,0.4) 90%);
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
        }
        
        /* Tilt Shift Blur */
        #tilt-shift-top, #tilt-shift-bottom {
            position: absolute;
            left: 0; width: 100%; height: 12%;
            backdrop-filter: blur(5px);
            z-index: 4;
            pointer-events: none;
        }
        #tilt-shift-top { top: 0; background: linear-gradient(to bottom, rgba(255,255,255,0.5), transparent); }
        #tilt-shift-bottom { bottom: 0; background: linear-gradient(to top, rgba(255,255,255,0.5), transparent); }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        h1 {
            font-family: 'DM Serif Display', serif;
            font-size: 3.5rem;
            color: #2c3e50;
            margin: 0;
            text-shadow: 2px 2px 0px rgba(255,255,255,0.5);
        }

        h2 {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #5d4037;
            font-weight: 800;
            margin-top: 5px;
            background: rgba(255,255,255,0.6);
            padding: 5px 10px;
            display: inline-block;
            border-radius: 4px;
        }

        .instruction-card {
            align-self: flex-end;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            padding: 25px 35px;
            border-radius: 12px;
            border-left: 5px solid #00BFFF;
            max-width: 320px;
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transform: translateY(20px);
            opacity: 0;
            animation: slideUp 1s forwards 1s;
        }

        @keyframes slideUp { to { transform: translateY(0); opacity: 1; } }

        .term { font-weight: 800; color: #2c3e50; display: block; margin-bottom: 6px; font-size: 1.1rem; }
        .def { font-size: 0.9rem; color: #555; line-height: 1.6; }

        /* Floating 3D Labels */
        .label-3d {
            position: absolute;
            background: rgba(255,255,255,0.9);
            color: #2c3e50;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            transform: translate(-50%, -150%);
            white-space: nowrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .label-3d.visible { opacity: 1; }
        .label-3d::after {
            content: ''; position: absolute; bottom: -5px; left: 50%;
            transform: translateX(-50%);
            border-left: 5px solid transparent; border-right: 5px solid transparent;
            border-top: 5px solid white;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: 'DM Serif Display';
            font-size: 2rem;
            z-index: 100;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        /* Credit footer */
        .experience-credit {
            position: fixed;
            bottom: 15px;
            right: 20px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            text-align: right;
            pointer-events: none;
            z-index: 100;
        }
        .experience-credit .designer {
            color: rgba(255, 215, 0, 0.6);
        }
    </style>
</head>
<body>
    <button class="back-button" onclick="window.history.back()">← Back to Prairie</button>

    <div id="loading">Preparing the harvest...</div>

    <!-- Cinematic Overlays -->
    <div id="vignette"></div>
    <div id="tilt-shift-top"></div>
    <div id="tilt-shift-bottom"></div>

    <div id="ui-layer">
        <header>
            <h1>Li Loo di Rivyair</h1>
            <h2>The River Lot System</h2>
        </header>

        <div class="instruction-card">
            <span class="term">Task: Plant the Fields</span>
            <span class="def">Click and drag along the long strip of land to plant <strong style="color:#D4AF37">Li Blay</strong> (Wheat). Métis farms connected to the water to ensure life flowed to the land.</span>
        </div>
    </div>

    <div id="labels-container"></div>
    <div id="canvas-container"></div>

    <!-- Scripts -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            lotWidth: 10,
            lotLength: 60,
            wheatCount: 4500,
            colors: {
                sky: 0x87CEEB,
                fog: 0xE0F7FA,
                water: 0x00BFFF, // Bright Deep Sky Blue
                waterHighlight: 0x40E0D0, // Turquoise
                ground: 0x6D4C41, // Warmer Earth
                grass: 0x7CB342, // Vibrant Green
                wheat: 0xFFD54F, // Golden Yellow
            }
        };

        // --- GLOBALS ---
        let scene, camera, renderer, composer, controls;
        let wheatMesh, dummy, raycaster, mouse;
        let groundMesh, riverMesh;
        let wheatData = []; 
        let isDragging = false;
        let time = 0;

        const labels = [
            { text: "La Rivyair (River)", pos: new THREE.Vector3(0, 1, -32) },
            { text: "La Mayzon (House)", pos: new THREE.Vector3(0, 3, -20) },
            { text: "Li Blay (Wheat)", pos: new THREE.Vector3(0, 2, 5) },
            { text: "La Tair (The Land)", pos: new THREE.Vector3(0, 1, 25) }
        ];

        // --- INIT ---
        function init() {
            const container = document.getElementById('canvas-container');
            document.getElementById('loading').style.display = 'none';

            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky); 
            // Fog matches the sky for seamless horizon
            scene.fog = new THREE.Fog(CONFIG.colors.fog, 30, 100);

            // Isometric-style Camera angle
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);
            
            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.SoftShadowMap; // Softer shadows for daylight
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            container.appendChild(renderer.domElement);

            // 3. Post Processing (Subtle Bloom for Sunlight)
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.65; // Only bloom very bright things
            bloomPass.strength = 0.4;   // Subtle glow
            bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // 4. Lighting (Bright Daylight)
            const ambient = new THREE.AmbientLight(0xffffff, 0.7); // High ambient for bright shadows
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffee, 1.8);
            sun.position.set(-30, 50, -10);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.bias = -0.0005;
            scene.add(sun);

            // 5. Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.minDistance = 20;
            controls.maxDistance = 80;

            // 6. Interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => isDragging = true);
            window.addEventListener('mouseup', () => isDragging = false);

            // --- BUILD THE WORLD ---
            createRiver();
            createGround();
            createHouse();
            initWheatField();
            createLabels();

            animate();
        }

        function createRiver() {
            // High segment count for wave animation
            const geo = new THREE.PlaneGeometry(100, 30, 60, 20);
            
            // Shiny, Low-Poly Water Material
            const mat = new THREE.MeshPhysicalMaterial({ 
                color: CONFIG.colors.water,
                emissive: 0x0044aa,
                emissiveIntensity: 0.1,
                roughness: 0.2, // Glossy
                metalness: 0.1, // Not metallic, just plastic/watery
                reflectivity: 1,
                flatShading: true, // IMPORTANT for Low Poly look
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            riverMesh = new THREE.Mesh(geo, mat);
            riverMesh.rotation.x = -Math.PI / 2;
            riverMesh.position.set(0, -0.5, -40); 
            riverMesh.receiveShadow = false; // Water doesn't really receive static shadow well in this style
            scene.add(riverMesh);
        }

        function createGround() {
            // The long narrow lot
            const geo = new THREE.BoxGeometry(CONFIG.lotWidth, 1, CONFIG.lotLength);
            const mat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.ground,
                roughness: 1,
            });
            groundMesh = new THREE.Mesh(geo, mat);
            groundMesh.position.y = -0.5;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Surrounding grass 
            const floorGeo = new THREE.PlaneGeometry(300, 300);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.grass, 
                roughness: 1 
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI/2;
            floor.position.y = -0.6;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        function createHouse() {
            const group = new THREE.Group();
            
            // White-washed Log Cabin (typical of some settlements) or natural wood
            const cabinGeo = new THREE.BoxGeometry(3, 2.5, 4);
            const cabinMat = new THREE.MeshStandardMaterial({ color: 0xA1887F }); 
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.y = 1.25;
            cabin.castShadow = true;
            group.add(cabin);

            // Dark Roof
            const roofGeo = new THREE.ConeGeometry(3.5, 1.5, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x3E2723 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 3.25;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            group.add(roof);

            // Door
            const doorGeo = new THREE.PlaneGeometry(1, 1.5);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x3E2723 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 1, 2.01);
            group.add(door);

            group.position.set(0, 0, -20);
            scene.add(group);
        }

        function initWheatField() {
            // Stalk Geometry
            const geo = new THREE.CylinderGeometry(0.08, 0.08, 1, 4);
            geo.translate(0, 0.5, 0); 

            const mat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.wheat,
                roughness: 0.5,
                metalness: 0
            });

            wheatMesh = new THREE.InstancedMesh(geo, mat, CONFIG.wheatCount);
            wheatMesh.castShadow = true;
            wheatMesh.receiveShadow = true;
            wheatMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); 

            dummy = new THREE.Object3D();

            for (let i = 0; i < CONFIG.wheatCount; i++) {
                const x = (Math.random() - 0.5) * (CONFIG.lotWidth - 1);
                const z = (Math.random() * 45) - 15; 

                dummy.position.set(x, 0, z);
                dummy.scale.set(0, 0, 0); 
                dummy.updateMatrix();
                wheatMesh.setMatrixAt(i, dummy.matrix);

                wheatData.push({
                    x: x, z: z,
                    scale: 0,
                    targetScale: 0,
                    swayOffset: Math.random() * Math.PI,
                    swaySpeed: 1 + Math.random() * 2
                });
            }

            scene.add(wheatMesh);
        }

        function createLabels() {
            const container = document.getElementById('labels-container');
            labels.forEach(l => {
                const div = document.createElement('div');
                div.className = 'label-3d visible';
                div.innerText = l.text;
                container.appendChild(div);
                l.element = div;
            });
        }

        function updateLabels() {
            labels.forEach(l => {
                const screenPos = l.pos.clone().project(camera);
                const x = (screenPos.x * .5 + .5) * window.innerWidth;
                const y = (screenPos.y * -.5 + .5) * window.innerHeight;
                l.element.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            });
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging) plantWheat();
        }

        function plantWheat() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(groundMesh);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const radius = 3.5;
                wheatData.forEach((data, i) => {
                    const dx = data.x - point.x;
                    const dz = data.z - point.z;
                    if ((dx*dx + dz*dz) < radius*radius) {
                        data.targetScale = 1; 
                    }
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ANIMATION ---

        function animate() {
            requestAnimationFrame(animate);
            time += 0.015;
            controls.update();

            // 1. Water Animation (Low Poly Waves)
            if (riverMesh) {
                const positions = riverMesh.geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i); // In local space, this is Z due to rotation
                    
                    // Sine wave based on X position and time
                    const zOffset = Math.sin(x * 0.5 + time) * 0.3 + Math.sin(y * 0.8 + time * 0.5) * 0.2;
                    
                    // We modify the Z attribute because plane is rotated
                    positions.setZ(i, zOffset);
                }
                positions.needsUpdate = true;
                
                // Recalculate normals so light catches the new waves
                riverMesh.geometry.computeVertexNormals();
            }

            // 2. Wheat Animation
            const windStrength = 0.15;
            let changed = false;

            for (let i = 0; i < CONFIG.wheatCount; i++) {
                const data = wheatData[i];

                if (Math.abs(data.scale - data.targetScale) > 0.01) {
                    data.scale += (data.targetScale - data.scale) * 0.1;
                    changed = true;
                }

                if (data.scale > 0.01) {
                    dummy.position.set(data.x, 0, data.z);
                    
                    const sway = Math.sin(time * data.swaySpeed + data.swayOffset) * windStrength;
                    dummy.rotation.z = sway; // Side to side
                    dummy.rotation.x = Math.sin(time * 0.5 + data.z) * 0.05; // Slight forward/back

                    dummy.scale.set(data.scale, data.scale * (1 + Math.random()*0.4), data.scale);
                    dummy.updateMatrix();
                    wheatMesh.setMatrixAt(i, dummy.matrix);
                    changed = true;
                }
            }

            if (changed) wheatMesh.instanceMatrix.needsUpdate = true;

            updateLabels();
            composer.render();
        }

        init();
    </script>

    <div class="experience-credit">
        Designed by <span class="designer">Amarah Ishaque</span><br>
        EDU596 Métis Foundational Knowledge
    </div>
</body>
</html>